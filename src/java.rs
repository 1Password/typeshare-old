use inflector::Inflector;
use std::io::Write;

use crate::language::{Language, Params, RustStruct, ACRONYMS};

pub struct Java {
    ids: Vec<String>,
}

impl Java {
    pub fn new() -> Self {
        Java { ids: Vec::new() }
    }
}

fn java_type(s: &str) -> &str {
    match s {
        "str" | "String" => "String",
        "i8" => "byte",
        "i16" => "short",
        "i32" => "int",
        "i64" => "long",
        "i128" => "java.math.BigInteger",
        "u8" => "byte",
        "u16" => "short",
        "u32" => "int",
        "u64" => "number",
        "f32" => "float",
        "f64" => "double",
        "isize" => "long",
        "usize" => "long",
        "bool" => "boolean",
        "char" => "char",
        _ => s,
    }
}

impl Language for Java {
    fn begin_file(&mut self, w: &mut dyn Write, _params: &Params) -> std::io::Result<()> {
        writeln!(w, "/**")?;
        writeln!(w, " * Generated by typeshare {}", env!("CARGO_PKG_VERSION"))?;
        writeln!(w, " */")?;
        writeln!(w)?;

        Ok(())
    }

    fn write_struct(&mut self, w: &mut dyn Write, _params: &Params, rs: &RustStruct) -> std::io::Result<()> {
        writeln!(w, "package {};", _params.java_package)?;
        writeln!(w)?;
        writeln!(w, "import com.fasterxml.jackson.annotation.*;")?;
        writeln!(w)?;

        write_comments(w, 0, &rs.comments)?;
        writeln!(w, "public class {} {{", rs.id.original)?;
        self.ids.push(rs.id.original.clone());

        for rf in rs.fields.iter() {
            if rf.is_vec {
                writeln!(w, "\tprivate {} {}[];", java_type(&rf.ty), rf.id.renamed)?;
            } else {
                writeln!(w, "\tprivate {} {};", java_type(&rf.ty), rf.id.renamed)?;
            }
        }
        writeln!(w)?;
        write_getter_setter(w, _params, rs)?;
        writeln!(w, "}}\n")?;
        Ok(())
    }

    fn end_file(&mut self, w: &mut dyn Write, _params: &Params) -> std::io::Result<()> {
        writeln!(w, "package {};", _params.java_package)?;
        writeln!(w)?;
        writeln!(w, "import java.io.IOException;")?;
        writeln!(w, "import com.fasterxml.jackson.databind.*;")?;
        writeln!(w, "import com.fasterxml.jackson.core.JsonProcessingException;")?;
        writeln!(w)?;
        writeln!(w, "/**")?;
        writeln!(w, " * Serialize/Deserialize helpers")?;
        writeln!(w, " */")?;
        writeln!(w, "public class Converter {{")?;
        writeln!(w)?;
        write_string_converter(&self.ids, 2, w)?;
        write_reader_writer_converter(&self.ids, 2, w)?;
        writeln!(w, "}}")?;
        Ok(())
    }
}

fn write_string_converter(ids: &Vec<String>, indent: usize, w: &mut dyn Write) -> std::io::Result<()> {
    for id in ids {
        writeln!(w, "{}public static {1} {1}FromJsonString(String json) throws IOException {{", "\t".repeat(indent - 1), id)?;
        writeln!(w, "{}return get{1}ObjectReader().readValue(json);", "\t".repeat(indent), id)?;
        writeln!(w, "{}}}", "\t".repeat(indent - 1))?;
        writeln!(w)?;
        writeln!(
            w,
            "{}public static String {1}ToJsonString({1} obj) throws JsonProcessingException {{",
            "\t".repeat(indent - 1),
            id
        )?;
        writeln!(w, "{}return get{1}ObjectWriter().writeValueAsString(obj);", "\t".repeat(indent), id)?;
        writeln!(w, "{}}}", "\t".repeat(indent - 1))?;
        writeln!(w)?;
    }
    Ok(())
}

fn write_reader_writer_converter(ids: &Vec<String>, indent: usize, w: &mut dyn Write) -> std::io::Result<()> {
    for id in ids {
        writeln!(w, "{}private static ObjectReader {}Reader;", "\t".repeat(indent - 1), id)?;
        writeln!(w, "{}private static ObjectWriter {}Writer;", "\t".repeat(indent - 1), id)?;
        writeln!(w)?;
        writeln!(w, "{}private static void instantiate{}Mapper() {{", "\t".repeat(indent - 1), id)?;
        writeln!(w, "{}ObjectMapper mapper = new ObjectMapper();", "\t".repeat(indent))?;
        writeln!(w, "{}{1}Reader = mapper.readerFor({1}.class);", "\t".repeat(indent), id)?;
        writeln!(w, "{}{1}Writer = mapper.writerFor({1}.class);", "\t".repeat(indent), id)?;
        writeln!(w, "{}}}", "\t".repeat(indent - 1))?;
        writeln!(w)?;
        writeln!(w, "{}private static ObjectReader get{}ObjectReader() {{", "\t".repeat(indent - 1), id)?;
        writeln!(w, "{}if ({1}Reader == null) instantiate{1}Mapper();", "\t".repeat(indent), id)?;
        writeln!(w, "{}return {}Reader;", "\t".repeat(indent), id)?;
        writeln!(w, "{}}}", "\t".repeat(indent - 1))?;
        writeln!(w)?;
        writeln!(w, "{}private static ObjectWriter get{}ObjectWriter() {{", "\t".repeat(indent - 1), id)?;
        writeln!(w, "{}if ({1}Writer == null) instantiate{1}Mapper();", "\t".repeat(indent), id)?;
        writeln!(w, "{}return {}Writer;", "\t".repeat(indent), id)?;
        writeln!(w, "{}}}", "\t".repeat(indent - 1))?;
        writeln!(w)?;
    }
    Ok(())
}

fn write_getter_setter(w: &mut dyn Write, _generator_params: &Params, rs: &RustStruct) -> std::io::Result<()> {
    for rf in rs.fields.iter() {
        write_comments(w, 1, &rf.comments)?;
        writeln!(w, "\t@JsonProperty(\"{0}\")", rf.id.renamed)?;
        let mut method_name = rf.id.renamed.to_pascal_case();
        if ACRONYMS.contains(&rf.id.renamed.as_str()) {
            method_name = rf.id.renamed.to_uppercase();
        }

        writeln!(w, "\tpublic {} get{}() {{ return {}; }}", java_type(&rf.ty), method_name, rf.id.renamed)?;
        writeln!(w, "\t@JsonProperty(\"{0}\")", rf.id.renamed)?;
        writeln!(w, "\tpublic void set{}({} value) {{ this.{} = value; }}", method_name, java_type(&rf.ty), rf.id.renamed)?;
        writeln!(w)?;
    }

    Ok(())
}

fn write_comment(w: &mut dyn Write, indent: usize, comment: &str) -> std::io::Result<()> {
    writeln!(w, "{} * {}", "\t".repeat(indent), comment)?;
    Ok(())
}

fn write_comments(w: &mut dyn Write, indent: usize, comments: &Vec<String>) -> std::io::Result<()> {
    writeln!(w, "{}/**", "\t".repeat(indent))?;
    for c in comments {
        write_comment(w, indent, &c)?;
    }
    writeln!(w, "{} */", "\t".repeat(indent))?;
    Ok(())
}
