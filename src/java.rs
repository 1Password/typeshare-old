use inflector::Inflector;
use std::io::Write;

use crate::language::{Language, Params, RustStruct, ACRONYMS};

pub struct Java {}

fn java_type(s: &str) -> &str {
    match s {
        "str" | "String" => "String",
        "i8" => "byte",
        "i16" => "short",
        "i32" => "int",
        "i64" => "long",
        "i128" => "java.math.BigInteger",
        "u8" => "byte",
        "u16" => "short",
        "u32" => "int",
        "u64" => "number",
        "f32" => "float",
        "f64" => "double",
        "isize" => "long",
        "usize" => "long",
        "bool" => "boolean",
        "char" => "char",
        _ => s,
    }
}

impl Language for Java {
    fn begin_file(&mut self, w: &mut dyn Write, _params: &Params) -> std::io::Result<()> {
        writeln!(w, "/**")?;
        writeln!(w, " * Generated by typeshare {}", env!("CARGO_PKG_VERSION"))?;
        writeln!(w, " */")?;
        writeln!(w)?;

        Ok(())
    }

    fn write_struct(&mut self, w: &mut dyn Write, _params: &Params, rs: &RustStruct) -> std::io::Result<()> {
        writeln!(w, "package {};", _params.java_package)?;
        writeln!(w)?;
        writeln!(w, "import com.fasterxml.jackson.annotation.*;")?;
        writeln!(w)?;

        write_comments(w, 0, &rs.comments)?;
        writeln!(w, "public class {} {{", rs.id.original)?;

        for rf in rs.fields.iter() {
            if rf.is_vec {
                writeln!(w, "\tprivate {} {}[];", java_type(&rf.ty), rf.id.renamed)?;
            } else {
                writeln!(w, "\tprivate {} {};", java_type(&rf.ty), rf.id.renamed)?;
            }
        }
        writeln!(w)?;
        write_getter_setter(w, _params, rs)?;
        writeln!(w, "}}\n")?;
        Ok(())
    }

    fn end_file(&mut self, w: &mut dyn Write, _params: &Params) -> std::io::Result<()> {
        writeln!(w, "/**")?;
        writeln!(w, " * DONE")?;
        writeln!(w, " */")?;
        writeln!(w)?;

        Ok(())
    }

}

fn write_getter_setter(w: &mut dyn Write, _generator_params: &Params, rs: &RustStruct) -> std::io::Result<()> {
    for rf in rs.fields.iter() {
        write_comments(w, 1, &rf.comments)?;
        writeln!(w, "\t@JsonProperty(\"{0}\")", rf.id.renamed)?;
        let mut method_name = rf.id.renamed.to_pascal_case();
        if ACRONYMS.contains(&rf.id.renamed.as_str()) {
            method_name = rf.id.renamed.to_uppercase();
        }

        writeln!(w, "\tpublic {} get{}() {{ return {}; }}", java_type(&rf.ty), method_name, rf.id.renamed)?;
        writeln!(w, "\t@JsonProperty(\"{0}\")", rf.id.renamed)?;
        writeln!(w, "\tpublic void set{}({} value) {{ this.{} = value; }}", method_name, java_type(&rf.ty), rf.id.renamed)?;
        writeln!(w)?;
    }

    Ok(())
}

fn write_comment(w: &mut dyn Write, indent: usize, comment: &str) -> std::io::Result<()> {
    writeln!(w, "{} * {}", "\t".repeat(indent), comment)?;
    Ok(())
}

fn write_comments(w: &mut dyn Write, indent: usize, comments: &Vec<String>) -> std::io::Result<()> {
    writeln!(w, "{}/**", "\t".repeat(indent))?;
    for c in comments {
        write_comment(w, indent, &c)?;
    }
    writeln!(w, "{} */", "\t".repeat(indent))?;
    Ok(())
}
