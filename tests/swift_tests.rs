use text_diff;
use typeshare::language::{Generator, Params};
use typeshare::swift;

#[test]
fn generate_types() {
    let mut lang = swift::Swift::new();
    let mut g = Generator::new(
        &mut lang,
        Params {
            use_marker: false,
            swift_prefix: "".to_string(),
            java_package: "".to_string(),
        },
    );

    let source = "
pub struct Types {
    pub s: String,
    pub int8: i8,
    pub float: f32,
    pub double: f64,
}
   
";

    let mut out: Vec<u8> = Vec::new();
    assert!(g.process_source(source.to_string(), &mut out).is_ok(), "must be able to process the source");
    let result = String::from_utf8(out).unwrap();

    let expected = format!(
        "/*
 Generated by typeshare {}
*/

import Foundation

public struct Types: Codable {{
	public let s: String
	public let int8: Int8
	public let float: Float
	public let double: Double

	public init(s: String, int8: Int8, float: Float, double: Double) {{
		self.s = s
		self.int8 = int8
		self.float = float
		self.double = double
	}}
}}


public extension Types {{
	init(data: Data) throws {{
		let decoded = try JSONDecoder().decode(Types.self, from: data)
		self.init(s: decoded.s, int8: decoded.int8, float: decoded.float, double: decoded.double)
	}}
}}

",
        env!("CARGO_PKG_VERSION")
    );

    if expected != result {
        text_diff::print_diff(&expected, &result, " ");
    }
    assert_eq!(expected, result);
}

#[test]
fn can_generate_simple_struct_with_a_comment() {
    let mut lang = swift::Swift::new();
    let mut g = Generator::new(
        &mut lang,
        Params {
            use_marker: false,
            swift_prefix: "".to_string(),
            java_package: "".to_string(),
        },
    );

    let source = "
/// This is a comment.
pub struct Person {
	pub name: String,
	pub age: u8,
	pub info: Option<String>,
	pub emails: Vec<String>,
}
   
";

    let mut out: Vec<u8> = Vec::new();
    assert!(g.process_source(source.to_string(), &mut out).is_ok(), "must be able to process the source");
    let result = String::from_utf8(out).unwrap();

    let expected = format!(
        "/*
 Generated by typeshare {}
*/

import Foundation

/// This is a comment.
public struct Person: Codable {{
	public let name: String
	public let age: UInt8
	public let info: String?
	public let emails: [String]

	public init(name: String, age: UInt8, info: String?, emails: [String]) {{
		self.name = name
		self.age = age
		self.info = info
		self.emails = emails
	}}
}}


public extension Person {{
	init(data: Data) throws {{
		let decoded = try JSONDecoder().decode(Person.self, from: data)
		self.init(name: decoded.name, age: decoded.age, info: decoded.info, emails: decoded.emails)
	}}
}}

",
        env!("CARGO_PKG_VERSION")
    );

    if expected != result {
        text_diff::print_diff(&expected, &result, " ");
    }
    assert_eq!(expected, result);
}

#[test]
fn can_handle_serde_rename() {
    let mut lang = swift::Swift::new();
    let mut g = Generator::new(
        &mut lang,
        Params {
            use_marker: true,
            swift_prefix: "TypeShareX_".to_string(),
            java_package: "".to_string(),
        },
    );

    let source = r##"
/// This is a comment.
#[typeshare()]
pub struct Person {
	pub name: String,
	pub age: u8,
	#[serde(rename="extraSpecialFieldOne")]
	pub extra_special_field1: i32,
	#[serde(rename="extraSpecialFieldTwo")]
	pub extra_special_field2: Option<Vec<String>>,
}
   
"##;

    let mut out: Vec<u8> = Vec::new();
    assert!(g.process_source(source.to_string(), &mut out).is_ok(), "must be able to process the source");
    let result = String::from_utf8(out).unwrap();

    let expected = format!(
        "/*
 Generated by typeshare {}
*/

import Foundation

/// This is a comment.
public struct TypeShareX_Person: Codable {{
	public let name: String
	public let age: UInt8
	public let extraSpecialFieldOne: Int32
	public let extraSpecialFieldTwo: [String]?

	public init(name: String, age: UInt8, extraSpecialFieldOne: Int32, extraSpecialFieldTwo: [String]?) {{
		self.name = name
		self.age = age
		self.extraSpecialFieldOne = extraSpecialFieldOne
		self.extraSpecialFieldTwo = extraSpecialFieldTwo
	}}
}}


public extension TypeShareX_Person {{
	init(data: Data) throws {{
		let decoded = try JSONDecoder().decode(TypeShareX_Person.self, from: data)
		self.init(name: decoded.name, age: decoded.age, extraSpecialFieldOne: decoded.extraSpecialFieldOne, extraSpecialFieldTwo: decoded.extraSpecialFieldTwo)
	}}
}}

",
        env!("CARGO_PKG_VERSION")
    );

    if expected != result {
        text_diff::print_diff(&expected, &result, " ");
    }
    assert_eq!(expected, result);
}

#[test]
fn can_generate_simple_enum() {
    let mut lang = swift::Swift::new();
    let mut g = Generator::new(
        &mut lang,
        Params {
            use_marker: false,
            swift_prefix: "TypeShare".to_string(),
            java_package: "".to_string(),
        },
    );

    let source = r##"
/// This is a comment.
pub enum Colors {
	Red = 0,
	Blue = 1,
	Green = 2,
}
   
"##;

    let mut out: Vec<u8> = Vec::new();
    assert!(g.process_source(source.to_string(), &mut out).is_ok(), "must be able to process the source");
    let result = String::from_utf8(out).unwrap();

    let expected = format!(
        "/*
 Generated by typeshare {}
*/

import Foundation

/// This is a comment.
public enum TypeShareColors: Int, Codable {{
	case Red = 0
	case Blue = 1
	case Green = 2
}}

",
        env!("CARGO_PKG_VERSION")
    );

    if expected != result {
        text_diff::print_diff(&expected, &result, " ");
    }
    assert_eq!(expected, result);
}

#[test]
fn can_generate_bare_string_enum() {
    let mut lang = swift::Swift::new();
    let mut g = Generator::new(
        &mut lang,
        Params {
            use_marker: false,
            swift_prefix: "".to_string(),
            java_package: "".to_string(),
        },
    );

    let source = r##"
/// This is a comment.
pub enum Colors {
	Red,
	Blue,
	Green,
}
   
"##;
    let mut out: Vec<u8> = Vec::new();
    assert!(g.process_source(source.to_string(), &mut out).is_ok(), "must be able to process the source");
    let result = String::from_utf8(out).unwrap();

    let expected = format!(
        r#"/*
 Generated by typeshare {}
*/

import Foundation

/// This is a comment.
public enum Colors: String, Codable {{
	case Red = "Red"
	case Blue = "Blue"
	case Green = "Green"
}}

"#,
        env!("CARGO_PKG_VERSION")
    );

    if expected != result {
        text_diff::print_diff(&expected, &result, " ");
    }
    assert_eq!(expected, result);
}

#[test]
fn can_generate_algebraic_enum() {
    let mut lang = swift::Swift::new();
    let mut g = Generator::new(
        &mut lang,
        Params {
            use_marker: false,
            swift_prefix: "OP".to_string(),
            java_package: "".to_string(),
        },
    );

    let string_enum = r##"
pub enum AdvancedColors {
    string(String),
    number(i32),
    numberArray(Vec<i32>),
    reallyCoolType(ItemDetailsFieldValue),
}"##;

    let mut out: Vec<u8> = Vec::new();
    assert!(g.process_source(string_enum.to_string(), &mut out).is_ok(), "must be able to process the source");
    let result = String::from_utf8(out).unwrap();

    let expected = format!(
        r#"/*
 Generated by typeshare {}
*/

import Foundation

public enum OPAdvancedColors: Codable {{
	case string(String)
	case number(Int32)
	case numberArray([Int32])
	case reallyCoolType(ItemDetailsFieldValue)

	public init(from decoder: Decoder) throws {{
		let container = try decoder.singleValueContainer()
		if let x = try? container.decode(String.self) {{
			self = .string(x)
			return
		}}
		if let x = try? container.decode(Int32.self) {{
			self = .number(x)
			return
		}}
		if let x = try? container.decode([Int32].self) {{
			self = .numberArray(x)
			return
		}}
		if let x = try? container.decode(ItemDetailsFieldValue.self) {{
			self = .reallyCoolType(x)
			return
		}}
		throw DecodingError.typeMismatch(OPAdvancedColors.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for OPAdvancedColors"))
	}}

	public func encode(to encoder: Encoder) throws {{
		var container = encoder.singleValueContainer()
		switch self {{
		case .string(let x):
			try container.encode(x)
		case .number(let x):
			try container.encode(x)
		case .numberArray(let x):
			try container.encode(x)
		case .reallyCoolType(let x):
			try container.encode(x)
		}}
	}}
}}

"#,
        env!("CARGO_PKG_VERSION")
    );

    if expected != result {
        text_diff::print_diff(&expected, &result, " ");
    }
    assert_eq!(expected, result);
}
